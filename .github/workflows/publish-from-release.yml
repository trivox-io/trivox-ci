name: Publish from Release Branch

on:
  workflow_call:
    inputs:
      release_branch:
        description: "Release branch name (e.g. release/0.6)"
        required: true
        type: string
      version_file:
        description: "Path to the version file"
        required: false
        type: string
        default: "pyproject.toml"
      apt-deps:
        description: "Space-separated APT packages to install before build"
        required: false
        type: string
        default: ""
      poetry-build-args:
        description: "Extra arguments to pass to 'poetry build'"
        required: false
        type: string
        default: ""
      build_wheels:
        description: "Build platform wheels with cibuildwheel and publish them"
        required: false
        type: boolean
        default: false
    secrets:
      PYPI_API_TOKEN:
        required: true
      SLACK_BOT_TOKEN:
        required: false
      SLACK_CHANNEL_ID_RELEASE:
        required: false

permissions:
  contents: write

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      start_unix: ${{ steps.start.outputs.start_unix }}
      version: ${{ steps.bump_and_tag.outputs.version }}
      changelog_section: ${{ steps.bump_and_tag.outputs.changelog_section }}
      ref: ${{ steps.ref.outputs.ref }}

    steps:
      - name: Mark start time
        id: start
        run: echo "start_unix=$(date +%s)" >> "$GITHUB_OUTPUT"

      - name: Validate release branch name
        run: |
          if [[ "${{ inputs.release_branch }}" != release/* ]]; then
            echo "ERROR: You can only publish from release/* branches."
            exit 1
          fi

      - name: Checkout release branch
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.release_branch }}
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

      - name: Bump patch if needed, update changelog, create tag
        id: bump_and_tag
        env:
          VERSION_FILE: ${{ inputs.version_file }}
        run: |
          # ... keep your current script unchanged ...

      - name: Resolve ref to build
        id: ref
        run: echo "ref=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

  wheels:
    if: ${{ inputs.build_wheels }}
    needs: [prepare]
    runs-on: windows-latest

    steps:
      - name: Checkout prepared ref
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.ref }}
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Windows deps (vcpkg)
        shell: pwsh
        run: |
          git clone https://github.com/microsoft/vcpkg "$PWD\vcpkg"
          & "$PWD\vcpkg\bootstrap-vcpkg.bat"
          & "$PWD\vcpkg\vcpkg.exe" install sdl2 sdl2-ttf --triplet x64-windows

      - name: Install cibuildwheel
        run: python -m pip install --upgrade pip cibuildwheel

      - name: Build wheels (x64 only)
        env:
          CIBW_ARCHS_WINDOWS: "AMD64"
          CIBW_BUILD: "cp39-win_amd64 cp310-win_amd64 cp311-win_amd64"
          CIBW_SKIP: "*-musllinux_*"
          CIBW_ENVIRONMENT_WINDOWS: >
            VCPKG_ROOT={project}/vcpkg
            CMAKE_TOOLCHAIN_FILE={project}/vcpkg/scripts/buildsystems/vcpkg.cmake
            SKBUILD_CMAKE_ARGS=-DCMAKE_TOOLCHAIN_FILE={project}/vcpkg/scripts/buildsystems/vcpkg.cmake
        run: python -m cibuildwheel --output-dir dist

      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheels-windows
          path: dist/*.whl

  publish:
    needs: [prepare, wheels]
    runs-on: ubuntu-latest

    outputs:
      start_unix: ${{ needs.prepare.outputs.start_unix }}
      version: ${{ needs.prepare.outputs.version }}
      changelog_section: ${{ needs.prepare.outputs.changelog_section }}

    steps:
      - name: Checkout prepared ref
        uses: actions/checkout@v4
        with:
          ref: ${{ needs.prepare.outputs.ref }}
          fetch-depth: 0

      - name: Install system dependencies (apt)
        if: ${{ inputs.apt-deps != '' }}
        run: |
          sudo apt-get update
          sudo apt-get install -y ${{ inputs.apt-deps }}

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install Poetry
        run: |
          python -m pip install --upgrade pip
          pip install "poetry>=2.0.0"

      - name: Build sdist/wheel (pure python projects)
        run: poetry build ${{ inputs.poetry-build-args }}

      - name: Download wheels
        if: ${{ inputs.build_wheels }}
        uses: actions/download-artifact@v4
        with:
          pattern: wheels-*
          merge-multiple: true
          path: dist

      - name: Publish to PyPI
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          user: __token__
          password: ${{ secrets.PYPI_API_TOKEN }}

  notify:
    needs: [publish]
    runs-on: ubuntu-latest
    if: always()

    env:
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      SLACK_CHANNEL_ID_RELEASE: ${{ secrets.SLACK_CHANNEL_ID_RELEASE }}

    steps:
      - name: Calculate pipeline duration
        id: duration
        run: |
          end=$(date +%s)
          seconds=$((end - ${{ needs.publish.outputs.start_unix }}))
          if [ "$seconds" -lt 60 ]; then
            formatted="${seconds}s"
          elif [ "$seconds" -lt 3600 ]; then
            minutes=$((seconds / 60)); secs=$((seconds % 60))
            formatted="${minutes}m"; [ "$secs" -ne 0 ] && formatted="${formatted} ${secs}s"
          else
            hours=$((seconds / 3600)); minutes=$(((seconds % 3600) / 60))
            formatted="${hours}h"; [ "$minutes" -ne 0 ] && formatted="${formatted} ${minutes}m"
          fi
          echo "time=${formatted}" >> "$GITHUB_OUTPUT"

      - name: Set pipeline status icon
        id: icon
        run: |
          if [[ "${{ needs.publish.result }}" != "success" ]]; then
            echo "icon=x" >> "$GITHUB_OUTPUT"
          else
            echo "icon=white_check_mark" >> "$GITHUB_OUTPUT"
          fi

      - name: Set pipeline status word
        id: word
        run: |
          if [[ "${{ needs.publish.result }}" != "success" ]]; then
            echo "word=failed" >> "$GITHUB_OUTPUT"
          else
            echo "word=passed" >> "$GITHUB_OUTPUT"
          fi

      - name: Get GitHub user full name
        id: ghname
        run: |
          name=$(curl -s https://api.github.com/users/${{ github.actor }} | jq -r .name)
          echo "name=${name}" >> "$GITHUB_OUTPUT"

      - name: Build payload JSON
        id: payload
        env:
          SERVER_URL:   ${{ github.server_url }}
          REPO:         ${{ github.repository }}
          RUN_ID:       ${{ github.run_id }}
          ACTOR:        ${{ github.actor }}
          BRANCH:       ${{ github.head_ref || github.ref_name }}
          COMMIT:       ${{ github.sha }}
          COMMIT_MSG:   ${{ github.event.head_commit.message || github.event.pull_request.title || 'Commit message not available' }}
          DURATION:     ${{ steps.duration.outputs.time }}
          ICON:         ${{ steps.icon.outputs.icon }}
          WORD:         ${{ steps.word.outputs.word }}
          NAME:         ${{ steps.ghname.outputs.name }}
          VERSION:      ${{ needs.publish.outputs.version }}
          CHANGELOG_SECTION_JSON: ${{ needs.publish.outputs.changelog_section }}
        run: |
          CHANGELOG_SECTION=$(printf '%s' "$CHANGELOG_SECTION_JSON" | jq -r .)

          blocks=$(jq -cn \
            --arg icon   "$ICON" \
            --arg name   "$NAME" \
            --arg server "$SERVER_URL" \
            --arg repo   "$REPO" \
            --arg runid  "$RUN_ID" \
            --arg actor  "$ACTOR" \
            --arg branch "$BRANCH" \
            --arg commit "$COMMIT" \
            --arg cmsg   "$COMMIT_MSG" \
            --arg dur    "$DURATION" \
            --arg word   "$WORD" \
            --arg version "$VERSION" \
            --arg chlog "$CHANGELOG_SECTION" '
            [
              {
                "type":"section",
                "text":{
                  "type":"mrkdwn",
                  "text": (":\($icon): *Release pipeline \((if ($name|length)>0 then $name else $actor end))* " +
                          "(<\($server)/\($actor)|@\($actor)>)\n" +
                          "Pipeline <\($server)/\($repo)/actions/runs/\($runid)|#\($runid)> has *\($word)* in `\($dur)`.")
                }
              },
              {
                "type":"section",
                "fields":[
                  { "type":"mrkdwn", "text":"*Branch:*\n<\($server)/\($repo)/tree/\($branch)|`\($branch)`>" },
                  { "type":"mrkdwn", "text":"*Commit:*\n<\($server)/\($repo)/commit/\($commit)|`\($commit)`> - `\($cmsg)`" }
                ]
              },
              {
                "type":"section",
                "text":{
                  "type":"mrkdwn",
                  "text":"*Release:* `v\($version)`\n\n\($chlog)"
                }
              }
            ]')

          payload=$(jq -cn \
            --arg icon "$ICON" \
            --arg server "$SERVER_URL" \
            --arg repo "$REPO" \
            --arg runid "$RUN_ID" \
            --arg word "$WORD" \
            --arg dur "$DURATION" \
            --argjson blocks "$blocks" '
            {
              "text": (":\($icon): Release pipeline <\($server)/\($repo)/actions/runs/\($runid)|#\($runid)> has *\($word)* in `\($dur)`."),
              "blocks": $blocks
            }')

          echo "payload=$(echo "$payload" | jq -c .)" >> "$GITHUB_OUTPUT"

      - name: Slack Notification
        if: env.SLACK_BOT_TOKEN != '' && env.SLACK_CHANNEL_ID_RELEASE != ''
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: ${{ env.SLACK_CHANNEL_ID_RELEASE }}
          payload: ${{ steps.payload.outputs.payload }}
        env:
          SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
