name: Python CI

on:
  workflow_call:
    inputs:
      project-name:
        required: true
        type: string
      lint-path:
        required: false
        type: string
        default: "src/mini_arcade_core"
    secrets:
      SLACK_BOT_TOKEN:
        required: false
      SLACK_CHANNEL_ID:
        required: false

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read

jobs:
  setup:
    runs-on: ubuntu-latest
    outputs:
      start: ${{ steps.set-start.outputs.start }}
      start_unix: ${{ steps.set-start.outputs.start_unix }}
    steps:
      - id: set-start
        run: |
          timestamp=$(date +%s)
          echo "start=$timestamp" >> $GITHUB_OUTPUT
          echo "start_unix=$timestamp" >> $GITHUB_OUTPUT

  lint-and-test:
    needs: [setup]
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        python-version: ["3.9", "3.10", "3.11"]

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install .[dev]

      - name: Run isort
        run: isort --check-only .

      - name: Run black
        run: black --check .

      - name: Run pylint
        run: pylint ${{ inputs.lint-path }}

      - name: Run pytest
        run: pytest

  notify:
    needs: [setup, lint-and-test]
    runs-on: ubuntu-latest
    if: always()

    env:
      SLACK_BOT_TOKEN: ${{ secrets.SLACK_BOT_TOKEN }}
      SLACK_CHANNEL_ID: ${{ secrets.SLACK_CHANNEL_ID }}

    steps:
      # 1) Duration
      - name: Calculate pipeline duration
        id: duration
        run: |
          end=$(date +%s)
          seconds=$((end - ${{ needs.setup.outputs.start }}))
          if [ "$seconds" -lt 60 ]; then
            formatted="${seconds}s"
          elif [ "$seconds" -lt 3600 ]; then
            minutes=$((seconds / 60)); secs=$((seconds % 60))
            formatted="${minutes}m"; [ "$secs" -ne 0 ] && formatted="${formatted} ${secs}s"
          else
            hours=$((seconds / 3600)); minutes=$(((seconds % 3600) / 60))
            formatted="${hours}h"; [ "$minutes" -ne 0 ] && formatted="${formatted} ${minutes}m"
          fi
          echo "time=${formatted}" >> "$GITHUB_OUTPUT"

      # 2) Icon & status word based on lint-and-test result
      - name: Set pipeline status icon
        id: icon
        run: |
          if [[ "${{ needs.lint-and-test.result }}" != "success" ]]; then
            echo "icon=x" >> "$GITHUB_OUTPUT"
          else
            echo "icon=white_check_mark" >> "$GITHUB_OUTPUT"
          fi

      - name: Set pipeline status word
        id: word
        run: |
          if [[ "${{ needs.lint-and-test.result }}" != "success" ]]; then
            echo "word=failed" >> "$GITHUB_OUTPUT"
          else
            echo "word=passed" >> "$GITHUB_OUTPUT"
          fi

      # 3) Get GitHub user full name
      - name: Get GitHub user full name
        id: ghname
        run: |
          name=$(curl -s https://api.github.com/users/${{ github.actor }} | jq -r .name)
          echo "name=${name}" >> "$GITHUB_OUTPUT"

      # 4) Build payload JSON
      - name: Build payload JSON
        id: payload
        env:
          SERVER_URL:   ${{ github.server_url }}
          REPO:         ${{ github.repository }}
          RUN_ID:       ${{ github.run_id }}
          ACTOR:        ${{ github.actor }}
          BRANCH:       ${{ github.head_ref || github.ref_name }}
          COMMIT:       ${{ github.sha }}
          COMMIT_MSG:   ${{ github.event.head_commit.message || github.event.pull_request.title || 'Commit message not available' }}
          START_UNIX:   ${{ needs.setup.outputs.start_unix }}
          DURATION:     ${{ steps.duration.outputs.time }}
          ICON:         ${{ steps.icon.outputs.icon }}
          WORD:         ${{ steps.word.outputs.word }}
          NAME:         ${{ steps.ghname.outputs.name }}
        run: |
          blocks=$(jq -cn \
            --arg icon   "$ICON" \
            --arg name   "$NAME" \
            --arg server "$SERVER_URL" \
            --arg repo   "$REPO" \
            --arg runid  "$RUN_ID" \
            --arg actor  "$ACTOR" \
            --arg branch "$BRANCH" \
            --arg commit "$COMMIT" \
            --arg cmsg   "$COMMIT_MSG" \
            --arg dur    "$DURATION" \
            --arg start  "$START_UNIX" \
            --arg word   "$WORD" '
            [
              {
                "type":"section",
                "text":{
                  "type":"mrkdwn",
                  "text": (":\($icon): *\((if ($name|length)>0 then $name else $actor end))* (<\($server)/\($actor)|@\($actor)>)\n" +
                          "Pipeline <\($server)/\($repo)/actions/runs/\($runid)|#\($runid)> has *\($word)* in `\($dur)`.") 
                }
              },
              {
                "type":"section",
                "fields":[
                  { "type":"mrkdwn", "text":"*Branch:*\n<\($server)/\($repo)/tree/\($branch)|`\($branch)`>" },
                  { "type":"mrkdwn", "text":"*Commit:*\n<\($server)/\($repo)/commit/\($commit)|`\($commit)`> - `\($cmsg)`" }
                ]
              },
              {
                "type":"context",
                "elements":[
                  { "type":"mrkdwn", "text":"<\($server)/\($repo)|\($repo)> Â· <!date^\($start)^{date_short_pretty} at {time}|Run time unavailable>" }
                ]
              }
            ]')

          payload=$(jq -cn \
            --arg icon "$ICON" \
            --arg server "$SERVER_URL" \
            --arg repo "$REPO" \
            --arg runid "$RUN_ID" \
            --arg word "$WORD" \
            --arg dur "$DURATION" \
            --argjson blocks "$blocks" '
            {
              "text": (":\($icon): CI Pipeline <\($server)/\($repo)/actions/runs/\($runid)|#\($runid)> has *\($word)* in `\($dur)`."), 
              "blocks": $blocks
            }')

          echo "payload=$(echo "$payload" | jq -c .)" >> "$GITHUB_OUTPUT"

      # 5) Send Slack
      - name: Slack Notification
        if: env.SLACK_BOT_TOKEN != '' && env.SLACK_CHANNEL_ID != ''
        uses: slackapi/slack-github-action@v1.24.0
        with:
          channel-id: ${{ env.SLACK_CHANNEL_ID }}
          payload: ${{ steps.payload.outputs.payload }}
        env:
          SLACK_BOT_TOKEN: ${{ env.SLACK_BOT_TOKEN }}
